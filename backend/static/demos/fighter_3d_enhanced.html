<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fighter - Enhanced Kinematics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
        }
        
        h2 {
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        button {
            display: block;
            width: 100%;
            padding: 10px 20px;
            margin-bottom: 10px;
            border: none;
            border-radius: 5px;
            background: #555;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            background: #666;
        }
        
        button.active {
            background: #3b82f6;
        }
        
        .info {
            margin-top: 20px;
            font-size: 0.85rem;
            color: #999;
        }
        
        .info p {
            margin: 5px 0;
        }
        
        .tech-label {
            color: #4ade80;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>Enhanced Kinematics</h2>
        <button id="idle-btn" class="active">Idle Stance</button>
        <button id="jab-btn">Jab</button>
        <button id="hook-btn">Hook</button>
        <button id="kick-btn">Kick</button>
        <button id="block-btn">Block</button>
        
        <div class="info">
            <p class="tech-label">✓ Bézier curve interpolation</p>
            <p class="tech-label">✓ Easing functions</p>
            <p class="tech-label">✓ Spring physics</p>
            <p class="tech-label">✓ Momentum carry-through</p>
            <p>✓ Real-time shadows</p>
            <p>✓ GPU-accelerated</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let leftFighter, rightFighter;
        let currentAnimation = 'idle';
        let time = 0;

        // ===========================
        // EASING & INTERPOLATION
        // ===========================
        
        const Easing = {
            // Cubic Bézier easing
            cubicBezier: function(t, p0, p1, p2, p3) {
                const u = 1 - t;
                return u*u*u*p0 + 3*u*u*t*p1 + 3*u*t*t*p2 + t*t*t*p3;
            },
            
            // Smooth ease in/out (starts slow, speeds up, slows down)
            easeInOutCubic: function(t) {
                return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3) / 2;
            },
            
            // Elastic overshoot (spring effect)
            easeOutElastic: function(t) {
                const c4 = (2 * Math.PI) / 3;
                return t === 0 ? 0 : t === 1 ? 1 : 
                    Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
            },
            
            // Back easing (wind up before motion)
            easeInBack: function(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return c3 * t * t * t - c1 * t * t;
            },
            
            // Out back (overshoot at end)
            easeOutBack: function(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            },
            
            // Exponential (rapid acceleration)
            easeOutExpo: function(t) {
                return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
            },
            
            // Smooth step (sigmoid-like)
            smoothstep: function(t) {
                return t * t * (3 - 2 * t);
            },
            
            // Smoother step (even more gradual)
            smootherstep: function(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
        };

        // Spring physics system
        class Spring {
            constructor(stiffness = 0.3, damping = 0.7) {
                this.stiffness = stiffness;
                this.damping = damping;
                this.velocity = 0;
                this.position = 0;
                this.target = 0;
            }
            
            update(dt = 0.016) {
                const force = (this.target - this.position) * this.stiffness;
                this.velocity += force;
                this.velocity *= this.damping;
                this.position += this.velocity * dt;
                return this.position;
            }
            
            setTarget(target) {
                this.target = target;
            }
            
            reset(value = 0) {
                this.position = value;
                this.velocity = 0;
                this.target = value;
            }
        }

        // Interpolate between quaternions (SLERP for smooth rotation)
        function slerpRotation(start, end, t) {
            // Simple lerp for Euler angles (good enough for this demo)
            return {
                x: start.x + (end.x - start.x) * t,
                y: start.y + (end.y - start.y) * t,
                z: start.z + (end.z - start.z) * t
            };
        }

        // ===========================
        // ANIMATION STATE MACHINE
        // ===========================
        
        class AnimationController {
            constructor() {
                this.currentState = 'idle';
                this.previousState = 'idle';
                this.stateTime = 0;
                this.transitionTime = 0.3; // Seconds for state transitions
                this.isTransitioning = false;
                this.transitionProgress = 0;
                
                // Springs for secondary motion
                this.headSpring = new Spring(0.4, 0.75);
                this.chestSpring = new Spring(0.35, 0.8);
                this.hipSpring = new Spring(0.3, 0.85);
            }
            
            setState(newState) {
                if (newState !== this.currentState) {
                    this.previousState = this.currentState;
                    this.currentState = newState;
                    this.isTransitioning = true;
                    this.transitionProgress = 0;
                    this.stateTime = 0;
                }
            }
            
            update(dt) {
                this.stateTime += dt;
                
                if (this.isTransitioning) {
                    this.transitionProgress += dt / this.transitionTime;
                    if (this.transitionProgress >= 1.0) {
                        this.transitionProgress = 1.0;
                        this.isTransitioning = false;
                    }
                }
                
                // Update springs for secondary motion
                this.headSpring.update(dt);
                this.chestSpring.update(dt);
                this.hipSpring.update(dt);
            }
            
            getBlendedPose(fighter) {
                if (!this.isTransitioning) {
                    return this.getPose(this.currentState, this.stateTime, fighter);
                }
                
                // Blend between previous and current pose
                const prevPose = this.getPose(this.previousState, this.stateTime, fighter);
                const currPose = this.getPose(this.currentState, this.stateTime, fighter);
                const t = Easing.smootherstep(this.transitionProgress);
                
                return this.blendPoses(prevPose, currPose, t);
            }
            
            getPose(state, time, fighter) {
                switch(state) {
                    case 'idle': return this.getIdlePose(time, fighter);
                    case 'jab': return this.getJabPose(time, fighter);
                    case 'hook': return this.getHookPose(time, fighter);
                    case 'kick': return this.getKickPose(time, fighter);
                    case 'block': return this.getBlockPose(time, fighter);
                    default: return this.getIdlePose(time, fighter);
                }
            }
            
            blendPoses(pose1, pose2, t) {
                const blended = {};
                for (let key in pose1) {
                    if (typeof pose1[key] === 'object' && pose1[key].x !== undefined) {
                        blended[key] = slerpRotation(pose1[key], pose2[key], t);
                    } else if (typeof pose1[key] === 'object' && pose1[key].y !== undefined) {
                        blended[key] = {
                            x: pose1[key].x + (pose2[key].x - pose1[key].x) * t,
                            y: pose1[key].y + (pose2[key].y - pose1[key].y) * t,
                            z: pose1[key].z + (pose2[key].z - pose1[key].z) * t
                        };
                    } else {
                        blended[key] = pose1[key] + (pose2[key] - pose1[key]) * t;
                    }
                }
                return blended;
            }
            
            getIdlePose(time, fighter) {
                // Subtle breathing with Bézier smoothing
                const breatheCycle = (time * 1.5) % 1.0;
                const breathe = Easing.cubicBezier(breatheCycle, 0, 0.2, 0.8, 1.0) * 0.03;
                
                // Gentle weight shift
                const sway = Math.sin(time * 0.8) * 0.02;
                
                return {
                    hips: { x: 0, y: sway, z: 0 },
                    spine: { x: 0, y: 0, z: 0 },
                    chest: { x: 0, y: 0, z: 0 },
                    chestScale: 1 + breathe,
                    neck: { x: 0, y: 0, z: 0 },
                    head: { x: Math.sin(time * 1.2) * 0.03, y: 0, z: 0 },
                    leftShoulder: { x: -0.8, y: 0, z: 0.3 },
                    leftElbow: { x: -1.2, y: 0, z: 0 },
                    rightShoulder: { x: -0.8, y: 0, z: -0.3 },
                    rightElbow: { x: -1.2, y: 0, z: 0 },
                    leftThigh: { x: 0, y: 0, z: 0 },
                    leftKnee: { x: 0.15, y: 0, z: 0 },
                    rightThigh: { x: 0, y: 0, z: 0 },
                    rightKnee: { x: 0.15, y: 0, z: 0 }
                };
            }
            
            getJabPose(time, fighter) {
                // Fast jab with proper phases
                const cycle = (time * 5.0) % 1.0;
                
                if (cycle < 0.15) {
                    // Wind-up (easeInBack for anticipation)
                    const t = Easing.easeInBack(cycle / 0.15);
                    return {
                        hips: { x: 0, y: t * -0.1, z: 0 },
                        spine: { x: 0, y: t * 0.15, z: 0 },
                        chest: { x: 0, y: t * 0.25, z: 0 },
                        chestScale: 1,
                        neck: { x: 0, y: 0, z: 0 },
                        head: { x: t * -0.1, y: 0, z: 0 },
                        leftShoulder: { x: -1.0 - t * 0.2, y: 0, z: 0.3 + t * 0.2 },
                        leftElbow: { x: -1.3 - t * 0.1, y: 0, z: 0 },
                        rightShoulder: { x: -0.8 - t * 0.5, y: 0, z: -0.3 },
                        rightElbow: { x: -1.2 + t * 0.8, y: 0, z: 0 },
                        leftThigh: { x: 0, y: 0, z: 0 },
                        leftKnee: { x: 0.15 + t * 0.1, y: 0, z: 0 },
                        rightThigh: { x: t * -0.15, y: 0, z: 0 },
                        rightKnee: { x: 0.15 + t * 0.15, y: 0, z: 0 }
                    };
                } else if (cycle < 0.25) {
                    // Explosion (easeOutExpo for speed)
                    const t = Easing.easeOutExpo((cycle - 0.15) / 0.1);
                    return {
                        hips: { x: 0, y: t * 0.05, z: 0 },
                        spine: { x: 0, y: t * 0.2, z: 0 },
                        chest: { x: 0, y: t * 0.35, z: 0 },
                        chestScale: 1,
                        neck: { x: 0, y: 0, z: 0 },
                        head: { x: t * -0.15, y: 0, z: 0 },
                        leftShoulder: { x: -1.2, y: 0, z: 0.5 },
                        leftElbow: { x: -1.4, y: 0, z: 0 },
                        rightShoulder: { x: -1.4 * t, y: 0, z: -0.3 },
                        rightElbow: { x: -0.2 * t, y: 0, z: 0 },
                        leftThigh: { x: 0, y: 0, z: 0 },
                        leftKnee: { x: 0.25, y: 0, z: 0 },
                        rightThigh: { x: -0.2 * t, y: 0, z: 0 },
                        rightKnee: { x: 0.35 * t, y: 0, z: 0 }
                    };
                } else {
                    // Recovery (smootherstep for natural return)
                    const t = 1.0 - Easing.smootherstep((cycle - 0.25) / 0.75);
                    return {
                        hips: { x: 0, y: t * 0.05, z: 0 },
                        spine: { x: 0, y: t * 0.2, z: 0 },
                        chest: { x: 0, y: t * 0.2, z: 0 },
                        chestScale: 1,
                        neck: { x: 0, y: 0, z: 0 },
                        head: { x: t * -0.08, y: 0, z: 0 },
                        leftShoulder: { x: -0.8 - t * 0.2, y: 0, z: 0.3 + t * 0.1 },
                        leftElbow: { x: -1.2 - t * 0.1, y: 0, z: 0 },
                        rightShoulder: { x: -0.8 - t * 0.3, y: 0, z: -0.3 },
                        rightElbow: { x: -1.2 + t * 0.8, y: 0, z: 0 },
                        leftThigh: { x: 0, y: 0, z: 0 },
                        leftKnee: { x: 0.15 + t * 0.05, y: 0, z: 0 },
                        rightThigh: { x: t * -0.1, y: 0, z: 0 },
                        rightKnee: { x: 0.15 + t * 0.1, y: 0, z: 0 }
                    };
                }
            }
            
            getHookPose(time, fighter) {
                const cycle = (time * 3.5) % 1.0;
                
                if (cycle < 0.2) {
                    // Wind up with back easing
                    const t = Easing.easeInBack(cycle / 0.2);
                    return {
                        hips: { x: 0, y: t * -0.5, z: 0 },
                        spine: { x: 0, y: t * -0.35, z: 0 },
                        chest: { x: 0, y: t * -0.25, z: 0 },
                        chestScale: 1 + t * 0.05,
                        neck: { x: 0, y: t * -0.15, z: 0 },
                        head: { x: 0, y: t * -0.2, z: 0 },
                        leftShoulder: { x: -0.5 * t, y: t * -0.8, z: 0.3 },
                        leftElbow: { x: -1.5 * t, y: 0, z: 0 },
                        rightShoulder: { x: -1.0 * t, y: 0, z: -0.3 },
                        rightElbow: { x: -1.3 * t, y: 0, z: 0 },
                        leftThigh: { x: t * -0.2, y: 0, z: 0 },
                        leftKnee: { x: 0.15 + t * 0.15, y: 0, z: 0 },
                        rightThigh: { x: 0, y: 0, z: 0 },
                        rightKnee: { x: 0.15, y: 0, z: 0 }
                    };
                } else if (cycle < 0.4) {
                    // Explosive rotation
                    const t = Easing.easeOutExpo((cycle - 0.2) / 0.2);
                    return {
                        hips: { x: 0, y: t * 0.7, z: 0 },
                        spine: { x: 0, y: t * 0.6, z: 0 },
                        chest: { x: 0, y: t * 0.5, z: 0 },
                        chestScale: 1 + t * 0.08,
                        neck: { x: 0, y: t * 0.3, z: 0 },
                        head: { x: t * -0.1, y: t * 0.4, z: 0 },
                        leftShoulder: { x: -0.3 * t, y: t * 1.3, z: 0.3 },
                        leftElbow: { x: -1.3 * t, y: 0, z: 0 },
                        rightShoulder: { x: -1.3 * t, y: 0, z: -0.3 },
                        rightElbow: { x: -1.5 * t, y: 0, z: 0 },
                        leftThigh: { x: t * 0.1, y: 0, z: 0 },
                        leftKnee: { x: 0.15, y: 0, z: 0 },
                        rightThigh: { x: t * -0.35, y: 0, z: 0 },
                        rightKnee: { x: 0.15 + t * 0.15, y: 0, z: 0 }
                    };
                } else {
                    // Recovery with elastic overshoot
                    const t = 1.0 - Easing.easeOutElastic((cycle - 0.4) / 0.6);
                    return {
                        hips: { x: 0, y: t * 0.3, z: 0 },
                        spine: { x: 0, y: t * 0.2, z: 0 },
                        chest: { x: 0, y: t * 0.1, z: 0 },
                        chestScale: 1 + t * 0.03,
                        neck: { x: 0, y: t * 0.1, z: 0 },
                        head: { x: t * -0.05, y: t * 0.1, z: 0 },
                        leftShoulder: { x: -0.8 + t * 0.3, y: t * 0.3, z: 0.3 },
                        leftElbow: { x: -1.2 - t * 0.1, y: 0, z: 0 },
                        rightShoulder: { x: -0.8 - t * 0.2, y: 0, z: -0.3 },
                        rightElbow: { x: -1.2 - t * 0.1, y: 0, z: 0 },
                        leftThigh: { x: 0, y: 0, z: 0 },
                        leftKnee: { x: 0.15, y: 0, z: 0 },
                        rightThigh: { x: 0, y: 0, z: 0 },
                        rightKnee: { x: 0.15, y: 0, z: 0 }
                    };
                }
            }
            
            getKickPose(time, fighter) {
                const cycle = (time * 2.8) % 1.0;
                
                if (cycle < 0.25) {
                    // Chamber with smooth acceleration
                    const t = Easing.easeInOutCubic(cycle / 0.25);
                    return {
                        hips: { x: 0, y: t * -0.35, z: 0 },
                        spine: { x: t * -0.1, y: t * -0.2, z: 0 },
                        chest: { x: t * -0.1, y: t * -0.15, z: 0 },
                        chestScale: 1,
                        neck: { x: 0, y: t * -0.1, z: 0 },
                        head: { x: t * -0.1, y: 0, z: 0 },
                        leftShoulder: { x: -0.5 * t, y: 0, z: 0.3 },
                        leftElbow: { x: -1.2 + t * 0.5, y: 0, z: 0 },
                        rightShoulder: { x: -0.5 * t, y: 0, z: -0.3 },
                        rightElbow: { x: -1.2 + t * 0.5, y: 0, z: 0 },
                        leftThigh: { x: 0, y: 0, z: 0 },
                        leftKnee: { x: 0.2 * t, y: 0, z: 0 },
                        rightThigh: { x: t * 1.4, y: 0, z: 0 },
                        rightKnee: { x: 0.15 - t * 1.7, y: 0, z: 0 }
                    };
                } else if (cycle < 0.5) {
                    // Extension with explosive power
                    const t = Easing.easeOutExpo((cycle - 0.25) / 0.25);
                    return {
                        hips: { x: 0, y: t * 0.9, z: 0 },
                        spine: { x: -0.1, y: t * 0.5, z: 0 },
                        chest: { x: -0.1, y: t * 0.4, z: 0 },
                        chestScale: 1 + t * 0.05,
                        neck: { x: 0, y: t * 0.2, z: 0 },
                        head: { x: -0.1 - t * 0.1, y: t * 0.15, z: 0 },
                        leftShoulder: { x: -0.3 * t, y: t * -0.6, z: 0.3 },
                        leftElbow: { x: -0.7, y: 0, z: 0 },
                        rightShoulder: { x: -0.3 * t, y: t * 0.6, z: -0.3 },
                        rightElbow: { x: -0.7, y: 0, z: 0 },
                        leftThigh: { x: 0, y: 0, z: 0 },
                        leftKnee: { x: 0.2, y: 0, z: 0 },
                        rightThigh: { x: 0.8 * t, y: t * 0.7, z: 0 },
                        rightKnee: { x: -1.5 + t * 1.3, y: 0, z: 0 }
                    };
                } else if (cycle < 0.7) {
                    // Retraction
                    const t = Easing.easeInOutCubic((cycle - 0.5) / 0.2);
                    return {
                        hips: { x: 0, y: 0.9 - t * 0.6, z: 0 },
                        spine: { x: -0.1 + t * 0.05, y: 0.5 - t * 0.3, z: 0 },
                        chest: { x: -0.1 + t * 0.05, y: 0.4 - t * 0.25, z: 0 },
                        chestScale: 1 + (1 - t) * 0.05,
                        neck: { x: 0, y: 0.2 - t * 0.15, z: 0 },
                        head: { x: -0.2 + t * 0.1, y: 0.15 - t * 0.1, z: 0 },
                        leftShoulder: { x: -0.3 + t * 0.1, y: -0.6 + t * 0.4, z: 0.3 },
                        leftElbow: { x: -0.7 - t * 0.3, y: 0, z: 0 },
                        rightShoulder: { x: -0.3 + t * 0.1, y: 0.6 - t * 0.4, z: -0.3 },
                        rightElbow: { x: -0.7 - t * 0.3, y: 0, z: 0 },
                        leftThigh: { x: 0, y: 0, z: 0 },
                        leftKnee: { x: 0.2 - t * 0.05, y: 0, z: 0 },
                        rightThigh: { x: 0.8 + t * 0.3, y: 0.7 - t * 0.5, z: 0 },
                        rightKnee: { x: -0.2 - t * 1.1, y: 0, z: 0 }
                    };
                } else {
                    // Return to stance with spring
                    const t = 1.0 - Easing.smootherstep((cycle - 0.7) / 0.3);
                    return {
                        hips: { x: 0, y: t * 0.15, z: 0 },
                        spine: { x: t * -0.05, y: t * 0.1, z: 0 },
                        chest: { x: t * -0.05, y: t * 0.08, z: 0 },
                        chestScale: 1,
                        neck: { x: 0, y: t * 0.03, z: 0 },
                        head: { x: t * -0.05, y: t * 0.02, z: 0 },
                        leftShoulder: { x: -0.8 + t * 0.3, y: t * -0.1, z: 0.3 },
                        leftElbow: { x: -1.2 + t * 0.2, y: 0, z: 0 },
                        rightShoulder: { x: -0.8 + t * 0.3, y: t * 0.1, z: -0.3 },
                        rightElbow: { x: -1.2 + t * 0.2, y: 0, z: 0 },
                        leftThigh: { x: 0, y: 0, z: 0 },
                        leftKnee: { x: 0.15, y: 0, z: 0 },
                        rightThigh: { x: t * 0.5, y: 0, z: 0 },
                        rightKnee: { x: 0.15 - t * 0.5, y: 0, z: 0 }
                    };
                }
            }
            
            getBlockPose(time, fighter) {
                // Tight defensive shell
                return {
                    hips: { x: 0, y: 0, z: 0 },
                    spine: { x: 0.1, y: 0, z: 0 },
                    chest: { x: 0.05, y: 0, z: 0 },
                    chestScale: 0.98,
                    neck: { x: 0.3, y: 0, z: 0 },
                    head: { x: -0.2, y: 0, z: 0 },
                    leftShoulder: { x: -1.5, y: 0, z: 0.5 },
                    leftElbow: { x: -1.8, y: 0, z: 0 },
                    rightShoulder: { x: -1.5, y: 0, z: -0.5 },
                    rightElbow: { x: -1.8, y: 0, z: 0 },
                    leftThigh: { x: 0, y: 0, z: 0 },
                    leftKnee: { x: 0.3, y: 0, z: 0 },
                    rightThigh: { x: 0, y: 0, z: 0 },
                    rightKnee: { x: 0.3, y: 0, z: 0 }
                };
            }
        }

        // ===========================
        // THREE.JS SETUP
        // ===========================

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 3, 10);
            camera.lookAt(0, 2, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(0, 15, 0);
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            scene.add(spotLight);

            const rimLight = new THREE.DirectionalLight(0x4444ff, 0.5);
            rimLight.position.set(5, 5, -5);
            scene.add(rimLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Ring ropes
            const ropeGeometry = new THREE.CylinderGeometry(0.05, 0.05, 12, 16);
            const ropeMaterial = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
            
            for (let i = 0; i < 3; i++) {
                const height = 0.5 + i * 0.5;
                const rope1 = new THREE.Mesh(ropeGeometry, ropeMaterial);
                rope1.rotation.z = Math.PI / 2;
                rope1.position.set(0, height, -6);
                scene.add(rope1);
                
                const rope2 = rope1.clone();
                rope2.position.z = 6;
                scene.add(rope2);
            }

            // Create fighters with animation controllers
            leftFighter = createFighter(0xff4444, -3);
            rightFighter = createFighter(0x4444ff, 3);
            scene.add(leftFighter.group);
            scene.add(rightFighter.group);

            // Button handlers
            document.getElementById('idle-btn').onclick = () => setAnimation('idle');
            document.getElementById('jab-btn').onclick = () => setAnimation('jab');
            document.getElementById('hook-btn').onclick = () => setAnimation('hook');
            document.getElementById('kick-btn').onclick = () => setAnimation('kick');
            document.getElementById('block-btn').onclick = () => setAnimation('block');

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Start animation
            animate();
        }

        function createFighter(color, xPosition) {
            const fighter = {
                group: new THREE.Group(),
                animController: new AnimationController(),
                bones: {}
            };
            
            fighter.group.position.x = xPosition;

            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.3
            });

            const darkMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(color).multiplyScalar(0.7),
                roughness: 0.8,
                metalness: 0.2
            });

            // === HIPS (root of skeleton) ===
            const hips = new THREE.Group();
            hips.position.y = 1.0;
            fighter.group.add(hips);
            fighter.bones.hips = hips;

            const hipsGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.4);
            const hipsMesh = new THREE.Mesh(hipsGeometry, darkMaterial);
            hipsMesh.castShadow = true;
            hips.add(hipsMesh);

            // === SPINE ===
            const spine = new THREE.Group();
            spine.position.y = 0.3;
            hips.add(spine);
            fighter.bones.spine = spine;

            const spineGeometry = new THREE.CylinderGeometry(0.2, 0.25, 0.4, 8);
            const spineMesh = new THREE.Mesh(spineGeometry, bodyMaterial);
            spineMesh.position.y = 0.2;
            spineMesh.castShadow = true;
            spine.add(spineMesh);

            // === CHEST ===
            const chest = new THREE.Group();
            chest.position.y = 0.4;
            spine.add(chest);
            fighter.bones.chest = chest;

            const chestGeometry = new THREE.BoxGeometry(0.7, 0.6, 0.4);
            const chestMesh = new THREE.Mesh(chestGeometry, bodyMaterial);
            chestMesh.position.y = 0.3;
            chestMesh.castShadow = true;
            chest.add(chestMesh);
            fighter.bones.chestMesh = chestMesh;

            // === NECK ===
            const neck = new THREE.Group();
            neck.position.y = 0.6;
            chest.add(neck);
            fighter.bones.neck = neck;

            const neckGeometry = new THREE.CylinderGeometry(0.12, 0.15, 0.25, 8);
            const neckMesh = new THREE.Mesh(neckGeometry, bodyMaterial);
            neckMesh.position.y = 0.125;
            neckMesh.castShadow = true;
            neck.add(neckMesh);

            // === HEAD ===
            const head = new THREE.Group();
            head.position.y = 0.25;
            neck.add(head);
            fighter.bones.head = head;

            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMesh = new THREE.Mesh(headGeometry, bodyMaterial);
            headMesh.position.y = 0.25;
            headMesh.castShadow = true;
            head.add(headMesh);

            // === SHOULDERS & ARMS ===
            ['left', 'right'].forEach(side => {
                const sign = side === 'left' ? 1 : -1;
                
                // Shoulder
                const shoulder = new THREE.Group();
                shoulder.position.set(sign * 0.35, 0.5, 0);
                chest.add(shoulder);
                fighter.bones[`${side}Shoulder`] = shoulder;

                const shoulderGeometry = new THREE.SphereGeometry(0.12, 12, 12);
                const shoulderMesh = new THREE.Mesh(shoulderGeometry, bodyMaterial);
                shoulderMesh.castShadow = true;
                shoulder.add(shoulderMesh);

                // Upper arm
                const upperArm = new THREE.Group();
                upperArm.position.y = -0.15;
                shoulder.add(upperArm);

                const upperArmGeometry = new THREE.CylinderGeometry(0.09, 0.1, 0.35, 8);
                const upperArmMesh = new THREE.Mesh(upperArmGeometry, bodyMaterial);
                upperArmMesh.position.y = -0.175;
                upperArmMesh.castShadow = true;
                upperArm.add(upperArmMesh);

                // Elbow
                const elbow = new THREE.Group();
                elbow.position.y = -0.35;
                upperArm.add(elbow);
                fighter.bones[`${side}Elbow`] = elbow;

                const elbowGeometry = new THREE.SphereGeometry(0.09, 10, 10);
                const elbowMesh = new THREE.Mesh(elbowGeometry, bodyMaterial);
                elbowMesh.castShadow = true;
                elbow.add(elbowMesh);

                // Forearm
                const forearm = new THREE.Group();
                forearm.position.y = -0.1;
                elbow.add(forearm);

                const forearmGeometry = new THREE.CylinderGeometry(0.075, 0.09, 0.35, 8);
                const forearmMesh = new THREE.Mesh(forearmGeometry, bodyMaterial);
                forearmMesh.position.y = -0.175;
                forearmMesh.castShadow = true;
                forearm.add(forearmMesh);

                // Glove
                const gloveGeometry = new THREE.SphereGeometry(0.12, 12, 12);
                const gloveMesh = new THREE.Mesh(gloveGeometry, darkMaterial);
                gloveMesh.position.y = -0.4;
                gloveMesh.castShadow = true;
                forearm.add(gloveMesh);
            });

            // === LEGS ===
            ['left', 'right'].forEach(side => {
                const sign = side === 'left' ? 1 : -1;
                
                // Thigh
                const thigh = new THREE.Group();
                thigh.position.set(sign * 0.2, -0.15, 0);
                hips.add(thigh);
                fighter.bones[`${side}Thigh`] = thigh;

                const thighGeometry = new THREE.CylinderGeometry(0.12, 0.14, 0.5, 10);
                const thighMesh = new THREE.Mesh(thighGeometry, bodyMaterial);
                thighMesh.position.y = -0.25;
                thighMesh.castShadow = true;
                thigh.add(thighMesh);

                // Knee
                const knee = new THREE.Group();
                knee.position.y = -0.5;
                thigh.add(knee);
                fighter.bones[`${side}Knee`] = knee;

                const kneeGeometry = new THREE.SphereGeometry(0.11, 12, 12);
                const kneeMesh = new THREE.Mesh(kneeGeometry, bodyMaterial);
                kneeMesh.castShadow = true;
                knee.add(kneeMesh);

                // Shin
                const shin = new THREE.Group();
                shin.position.y = -0.1;
                knee.add(shin);

                const shinGeometry = new THREE.CylinderGeometry(0.09, 0.11, 0.45, 10);
                const shinMesh = new THREE.Mesh(shinGeometry, bodyMaterial);
                shinMesh.position.y = -0.225;
                shinMesh.castShadow = true;
                shin.add(shinMesh);

                // Foot
                const footGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.3);
                const footMesh = new THREE.Mesh(footGeometry, darkMaterial);
                footMesh.position.set(0, -0.5, 0.08);
                footMesh.castShadow = true;
                shin.add(footMesh);
            });

            return fighter;
        }

        function updateFighterAnimation(fighter) {
            fighter.animController.update(0.016);
            const pose = fighter.animController.getBlendedPose(fighter);
            
            // Apply pose to skeleton
            const bones = fighter.bones;
            
            bones.hips.rotation.set(pose.hips.x, pose.hips.y, pose.hips.z);
            bones.spine.rotation.set(pose.spine.x, pose.spine.y, pose.spine.z);
            bones.chest.rotation.set(pose.chest.x, pose.chest.y, pose.chest.z);
            bones.chestMesh.scale.y = pose.chestScale || 1;
            bones.neck.rotation.set(pose.neck.x, pose.neck.y, pose.neck.z);
            bones.head.rotation.set(pose.head.x, pose.head.y, pose.head.z);
            
            bones.leftShoulder.rotation.set(pose.leftShoulder.x, pose.leftShoulder.y, pose.leftShoulder.z);
            bones.leftElbow.rotation.set(pose.leftElbow.x, pose.leftElbow.y, pose.leftElbow.z);
            bones.rightShoulder.rotation.set(pose.rightShoulder.x, pose.rightShoulder.y, pose.rightShoulder.z);
            bones.rightElbow.rotation.set(pose.rightElbow.x, pose.rightElbow.y, pose.rightElbow.z);
            
            bones.leftThigh.rotation.set(pose.leftThigh.x, pose.leftThigh.y, pose.leftThigh.z);
            bones.leftKnee.rotation.set(pose.leftKnee.x, pose.leftKnee.y, pose.leftKnee.z);
            bones.rightThigh.rotation.set(pose.rightThigh.x, pose.rightThigh.y, pose.rightThigh.z);
            bones.rightKnee.rotation.set(pose.rightKnee.x, pose.rightKnee.y, pose.rightKnee.z);
        }

        function setAnimation(anim) {
            currentAnimation = anim;
            leftFighter.animController.setState(anim);
            rightFighter.animController.setState(anim);
            
            // Update button states
            document.querySelectorAll('#controls button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(anim + '-btn').classList.add('active');
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            updateFighterAnimation(leftFighter);
            updateFighterAnimation(rightFighter);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();
    </script>
</body>
</html>
